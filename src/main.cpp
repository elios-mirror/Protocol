#include <assert.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#define NAPI_EXPERIMENTAL
#include <node_api.h>
#include <node_api_types.h>

#include "Communication.hpp"

typedef struct
{
  napi_async_work work;
  napi_threadsafe_function tsfn;
  Communication *protocolInstance;
  napi_value input;
} AddonData;

typedef struct
{
  protocol_t header;
  std::string message;
} Payload;

// This function is responsible for converting data coming in from the worker
// thread to napi_value items that can be passed into JavaScript, and for
// calling the JavaScript function.
static void
CallJs(napi_env env, napi_value js_cb, void *context, void *data)
{
  // This parameter is not used.
  (void)context;
  const Payload *payload = (Payload *)data;

  if (env != NULL)
  {
    napi_value undefined, callback_data[2];

    // Convert the integer to a napi_value.
    napi_create_string_utf8(env, payload->message.c_str(), payload->header.payload_size, &callback_data[0]);
    napi_create_int32(env, payload->header.command_type, &callback_data[1]);

    // Retrieve the JavaScript `undefined` value so we can use it as the `this`
    // value of the JavaScript function call.
    napi_get_undefined(env, &undefined);

    // Call the JavaScript function and pass it the prime that the secondary
    // thread found.
    napi_call_function(env,
                       undefined,
                       js_cb,
                       2,
                       callback_data,
                       NULL);
  }
  delete (payload);
}

// This function runs on a worker thread. It has no access to the JavaScript
// environment except through the thread-safe function.
static void ExecuteWork(napi_env env, void *data)
{
  // We bracket the use of the thread-safe function by this thread by a call to
  // napi_acquire_threadsafe_function() here, and by a call to
  // napi_release_threadsafe_function() immediately prior to thread exit.
  static AddonData *addon_data = (AddonData *)data;
  napi_acquire_threadsafe_function(addon_data->tsfn);

  // Find the first 1000 prime numbers using an extremely inefficient algorithm.
  std::function<void(const protocol_t &, const std::string &)> callBackFunction = [](const protocol_t &header, const std::string &message) {
    const Payload *payload = new Payload{header, message};
    napi_call_threadsafe_function(addon_data->tsfn,
                                  (void *)payload,
                                  napi_tsfn_blocking);
  };
  addon_data->protocolInstance->receive(callBackFunction);

  // Indicate that this thread will make no further use of the thread-safe function.
  napi_release_threadsafe_function(addon_data->tsfn,
                                   napi_tsfn_release);
}

// This function runs on the main thread after `ExecuteWork` exits.
static void WorkComplete(napi_env env, napi_status status, void *data)
{
  AddonData *addon_data = (AddonData *)data;

  // Clean up the thread-safe function and the work item associated with this
  // run.
  napi_release_threadsafe_function(addon_data->tsfn,
                                   napi_tsfn_release);
  napi_delete_async_work(env, addon_data->work);

  // Set both values to NULL so JavaScript can order a new run of the thread.
  addon_data->work = NULL;
  addon_data->tsfn = NULL;
}

// Create a thread-safe function and an async queue work item. We pass the
// thread-safe function to the async queue work item so the latter might have a
// chance to call into JavaScript from the worker thread on which the
// ExecuteWork callback runs.
static napi_value ReceiveFunction(napi_env env, napi_callback_info info)
{
  size_t argc = 1;
  napi_value js_cb, work_name;
  AddonData *addon_data;

  // Retrieve the JavaScript callback we should call with items generated by the
  // worker thread, and the per-addon data.
  napi_get_cb_info(env,
                   info,
                   &argc,
                   &js_cb,
                   NULL,
                   (void **)(&addon_data));

  // Create a string to describe this asynchronous operation.
  napi_create_string_utf8(env,
                          "N-API Thread-safe Call from Async Work Item",
                          NAPI_AUTO_LENGTH,
                          &work_name);

  // Convert the callback retrieved from JavaScript into a thread-safe function
  // which we can call from a worker thread.
  napi_create_threadsafe_function(env,
                                  js_cb,
                                  NULL,
                                  work_name,
                                  0,
                                  1,
                                  NULL,
                                  NULL,
                                  NULL,
                                  CallJs,
                                  &(addon_data->tsfn));

  // Create an async work item, passing in the addon data, which will give the
  // worker thread access to the above-created thread-safe function.
  napi_create_async_work(env,
                         NULL,
                         work_name,
                         ExecuteWork,
                         WorkComplete,
                         addon_data,
                         &(addon_data->work));

  // Queue the work item for execution.
  napi_queue_async_work(env, addon_data->work);

  // This causes `undefined` to be returned to JavaScript.
  return NULL;
}

// Free the per-addon-instance data.
static void addon_getting_unloaded(napi_env env, void *data, void *hint)
{
  AddonData *addon_data = (AddonData *)data;
  free(addon_data);
}

static napi_value SendFunction(napi_env env, napi_callback_info info)
{
  napi_status status;
  int command_type = 0;
  size_t argc = 2;
  size_t len;
  napi_value args[argc];
  napi_value js_cb;
  AddonData *addon_data;

  status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);

  if (argc < 1)
  {
    napi_throw_type_error(env, nullptr, "Wrong number of arguments");
    return nullptr;
  }

  // Get the length of the string by passing NULL as the buf
  status = napi_get_value_string_utf8(env, args[0], NULL, 0, &len);
  if (status != napi_ok)
  {
    napi_throw_error(env, NULL, "Could not get string length");
  }

  char *message = (char *)malloc(sizeof(char) * (len + 1)); // +1 for null termination
  status = napi_get_value_string_utf8(env, args[0], message, len + 1, &len);
  if (status != napi_ok)
  {
    napi_throw_error(env, NULL, "Could not extract string");
  }

  if (argc == 2)
  {
    status = napi_get_value_int32(env, args[1], &command_type);
    if (status != napi_ok)
    {
      napi_throw_error(env, NULL, "Could not extract int");
    }
  }

  // Retrieve the JavaScript callback we should call with items generated by the
  // worker thread, and the per-addon data.
  napi_get_cb_info(env,
                   info,
                   &argc,
                   &js_cb,
                   NULL,
                   (void **)(&addon_data));

  addon_data->protocolInstance->send({message}, command_type);
  free(message);
  return NULL;
}

static napi_value CloseFunction(napi_env env, napi_callback_info info)
{
  napi_status status;
  int command_type = 0;
  size_t argc = 0;
  size_t len;
  AddonData *addon_data;

  // Retrieve the JavaScript callback we should call with items generated by the
  // worker thread, and the per-addon data.
  napi_get_cb_info(env,
                   info,
                   &argc,
                   NULL,
                   NULL,
                   (void **)(&addon_data));
  addon_data->protocolInstance->quit();
  return NULL;
}

napi_value CreateObject(napi_env env, const napi_callback_info info)
{
  napi_status status;

  size_t argc = 1;
  napi_value args[argc];
  status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
  assert(status == napi_ok);

  napi_value obj;
  status = napi_create_object(env, &obj);
  assert(status == napi_ok);

  status = napi_set_named_property(env, obj, "socket_path", args[0]);
  assert(status == napi_ok);

  // Get socket_path
  size_t len;

  // Get the length of the string by passing NULL as the buf
  status = napi_get_value_string_utf8(env, args[0], NULL, 0, &len);
  if (status != napi_ok)
  {
    napi_throw_error(env, NULL, "Could not get string length");
  }

  char *socket_path = (char *)malloc(sizeof(char) * (len + 1)); // +1 for null termination
  status = napi_get_value_string_utf8(env, args[0], socket_path, len + 1, &len);
  if (status != napi_ok)
  {
    napi_throw_error(env, NULL, "Could not extract string");
  }

  // Define addon-level data associated with this instance of the addon.
  AddonData *addon_data = (AddonData *)malloc(sizeof(*addon_data));
  addon_data->work = NULL;
  addon_data->protocolInstance = new Communication(socket_path);

  // Define the properties that will be set on exports.
  napi_property_descriptor receive_function = {
      "receive",
      NULL,
      ReceiveFunction,
      NULL,
      NULL,
      NULL,
      napi_default,
      addon_data};

  napi_property_descriptor send_function = {
      "send",
      NULL,
      SendFunction,
      NULL,
      NULL,
      NULL,
      napi_default,
      addon_data};

  napi_property_descriptor close_function = {
      "close",
      NULL,
      CloseFunction,
      NULL,
      NULL,
      NULL,
      napi_default,
      addon_data};

  // Decorate exports with the above-defined properties.
  napi_define_properties(env, obj, 1, &receive_function);
  napi_define_properties(env, obj, 1, &send_function);
  napi_define_properties(env, obj, 1, &close_function);

  // Associate the addon data with the exports object, to make sure that when
  // the addon gets unloaded our data gets freed.
  napi_wrap(env,
            obj,
            addon_data,
            addon_getting_unloaded,
            NULL,
            NULL);

  return obj;
}

NAPI_MODULE_INIT()
{
  napi_status status =
      napi_create_function(env, "", NAPI_AUTO_LENGTH, CreateObject, nullptr, &exports);
  assert(status == napi_ok);
  return exports;
}