#include "receive.hpp"
#include "send.hpp"

// Free the per-addon-instance data.
static void release_receive_function(napi_env env, void *data, void *hint) {
  ReceiveData *addon_data = (ReceiveData *)data;
  free(addon_data);
}

static void release_send_function(napi_env env, void *data, void *hint) {
  SendData *addon_data = (SendData *)data;
  if (addon_data->message != NULL) {
    free(addon_data->message);
  }
  // free(addon_data);
}

static napi_value CloseFunction(napi_env env, napi_callback_info info) {
  size_t argc = 0;
  ReceiveData *addon_data;

  // Retrieve the JavaScript callback we should call with items generated by the
  // worker thread, and the per-addon data.
  napi_get_cb_info(env, info, &argc, NULL, NULL, (void **)(&addon_data));
  addon_data->protocolInstance->quit();
  return NULL;
}

napi_value CreateObject(napi_env env, const napi_callback_info info) {
  napi_status status;
  bool sdk = false;

  size_t argc = 2;
  napi_value args[argc];
  status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
  assert(status == napi_ok);

  napi_value obj;
  status = napi_create_object(env, &obj);
  assert(status == napi_ok);

  status = napi_set_named_property(env, obj, "socket_path", args[0]);
  assert(status == napi_ok);

  // Get socket_path
  size_t len;

  // Get the length of the string by passing NULL as the buf
  status = napi_get_value_string_utf8(env, args[0], NULL, 0, &len);
  if (status != napi_ok) {
    napi_throw_error(env, NULL, "Could not get string length");
  }

  char *socket_path =
      (char *)malloc(sizeof(char) * (len + 1)); // +1 for null termination
  status = napi_get_value_string_utf8(env, args[0], socket_path, len + 1, &len);
  if (status != napi_ok) {
    napi_throw_error(env, NULL, "Could not extract string");
  }

  if (argc == 2) {
    status = napi_get_value_bool(env, args[1], &sdk);
    if (status != napi_ok) {
      napi_throw_error(env, NULL, "Could not extract sdk ?");
    }
  }

  Communication *protocolInstance = new Communication(socket_path, sdk);

  // Define addon-level data associated with this instance of the addon.
  ReceiveData *addon_data_receive =
      (ReceiveData *)malloc(sizeof(*addon_data_receive));
  SendData *addon_data_send = (SendData *)malloc(sizeof(*addon_data_send));

  addon_data_receive->work = NULL;
  addon_data_send->work = NULL;
  addon_data_receive->tsfn = NULL;
  addon_data_send->tsfn = NULL;


  addon_data_receive->protocolInstance = protocolInstance;
  addon_data_send->protocolInstance = protocolInstance;

  // Define the properties that will be set on exports.
  napi_property_descriptor receive_function = {
      "receive", NULL, ReceiveFunction, NULL,
      NULL,      NULL, napi_default,    addon_data_receive};

  napi_property_descriptor send_function = {
      "send", NULL, SendFunction, NULL,
      NULL,   NULL, napi_default, addon_data_send};

  napi_property_descriptor close_function = {
      "close", NULL, CloseFunction, NULL,
      NULL,    NULL, napi_default,  addon_data_receive};

  // Decorate exports with the above-defined properties.
  napi_define_properties(env, obj, 1, &receive_function);
  napi_define_properties(env, obj, 1, &send_function);
  napi_define_properties(env, obj, 1, &close_function);

  // Associate the addon data with the exports object, to make sure that when
  // the addon gets unloaded our data gets freed.
  napi_wrap(env, obj, addon_data_send, release_send_function, NULL, NULL);
  napi_wrap(env, obj, addon_data_receive, release_receive_function, NULL, NULL);

  return obj;
}

NAPI_MODULE_INIT() {
  napi_status status = napi_create_function(env, "", NAPI_AUTO_LENGTH,
                                            CreateObject, nullptr, &exports);
  assert(status == napi_ok);
  return exports;
}