#include "receive.hpp"

static napi_value Test(napi_env env, const napi_callback_info info) {
  napi_status status;
  int command_type = 0;
  size_t argc = 2;
  size_t len;
  napi_value args[argc];
  napi_value js_cb;
  Payload *payload;

  status = napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);

  if (argc < 1) {
    napi_throw_type_error(env, nullptr, "Wrong number of arguments");
    return nullptr;
  }

  // Get the length of the string by passing NULL as the buf
  status = napi_get_value_string_utf8(env, args[0], NULL, 0, &len);
  if (status != napi_ok) {
    napi_throw_error(env, NULL, "Could not get string length");
  }

  char *message =
      (char *)malloc(sizeof(char) * (len + 1)); // +1 for null termination
  status = napi_get_value_string_utf8(env, args[0], message, len + 1, &len);
  if (status != napi_ok) {
    napi_throw_error(env, NULL, "Could not extract string");
  }

  if (argc == 2) {
    status = napi_get_value_int32(env, args[1], &command_type);
    if (status != napi_ok) {
      napi_throw_error(env, NULL, "Could not extract int");
    }
  }

  // Retrieve the JavaScript callback we should call with items generated by the
  // worker thread, and the per-addon data.
  napi_get_cb_info(env, info, &argc, &js_cb, NULL, (void **)(&payload));
  std::string msg(message);
  payload->replyFunction(msg, command_type);
  free(message);
  return NULL;
}

// This function is responsible for converting data coming in from the worker
// thread to napi_value items that can be passed into JavaScript, and for
// calling the JavaScript function.
static void CallJsReceive(napi_env env, napi_value js_cb, void *context,
                          void *data) {
  // This parameter is not used.
  (void)context;
  const Payload *payload = (Payload *)data;

  if (env != NULL) {
    napi_value undefined, callback_data[3];

    // Convert the integer to a napi_value.
    napi_create_string_utf8(env, payload->message.c_str(),
                            payload->header.payload_size, &callback_data[0]);
    napi_create_int32(env, payload->header.command_type, &callback_data[1]);
    napi_create_function(env, "", NAPI_AUTO_LENGTH, Test, (void *)payload,
                         &callback_data[2]);

    // Retrieve the JavaScript `undefined` value so we can use it as the `this`
    // value of the JavaScript function call.
    napi_get_undefined(env, &undefined);

    // Call the JavaScript function and pass it the prime that the secondary
    // thread found.
    napi_call_function(env, undefined, js_cb, 3, callback_data, NULL);
  }
  delete (payload);
}

// This function runs on a worker thread. It has no access to the JavaScript
// environment except through the thread-safe function.
static void ExecuteWorkReceive(napi_env env, void *data) {
  // We bracket the use of the thread-safe function by this thread by a call to
  // napi_acquire_threadsafe_function() here, and by a call to
  // napi_release_threadsafe_function() immediately prior to thread exit.
  static ReceiveData *addon_data = (ReceiveData *)data;
  napi_acquire_threadsafe_function(addon_data->tsfn);

  // Find the first 1000 prime numbers using an extremely inefficient algorithm.
  std::function<void(const protocol_t &, const std::string &,
                     std::function<void(std::string &, int)>)>
      callBackFunction = [](const protocol_t &header,
                            const std::string &message,
                            std::function<void(std::string &, int)>
                                replyFunction) {
        const Payload *payload = new Payload{header, message, replyFunction};
        napi_call_threadsafe_function(addon_data->tsfn, (void *)payload,
                                      napi_tsfn_blocking);
      };
  addon_data->protocolInstance->receive(callBackFunction);

  // Indicate that this thread will make no further use of the thread-safe
  // function.
  napi_release_threadsafe_function(addon_data->tsfn, napi_tsfn_release);
}

// This function runs on the main thread after `ExecuteWork` exits.
static void WorkCompleteReceive(napi_env env, napi_status status, void *data) {
  ReceiveData *addon_data = (ReceiveData *)data;

  // Clean up the thread-safe function and the work item associated with this
  // run.
  napi_release_threadsafe_function(addon_data->tsfn, napi_tsfn_release);
  napi_delete_async_work(env, addon_data->work);

  // Set both values to NULL so JavaScript can order a new run of the thread.
  addon_data->work = NULL;
  addon_data->tsfn = NULL;
}

// Create a thread-safe function and an async queue work item. We pass the
// thread-safe function to the async queue work item so the latter might have a
// chance to call into JavaScript from the worker thread on which the
// ExecuteWork callback runs.
napi_value ReceiveFunction(napi_env env, napi_callback_info info) {
  size_t argc = 1;
  napi_value js_cb, work_name;
  ReceiveData *addon_data;

  // Retrieve the JavaScript callback we should call with items generated by the
  // worker thread, and the per-addon data.
  napi_get_cb_info(env, info, &argc, &js_cb, NULL, (void **)(&addon_data));

  // Create a string to describe this asynchronous operation.
  napi_create_string_utf8(env, "N-API Thread-safe Call from Async Work Item",
                          NAPI_AUTO_LENGTH, &work_name);

  // Convert the callback retrieved from JavaScript into a thread-safe function
  // which we can call from a worker thread.
  napi_create_threadsafe_function(env, js_cb, NULL, work_name, 0, 1, NULL, NULL,
                                  NULL, CallJsReceive, &(addon_data->tsfn));

  // Create an async work item, passing in the addon data, which will give the
  // worker thread access to the above-created thread-safe function.
  napi_create_async_work(env, NULL, work_name, ExecuteWorkReceive,
                         WorkCompleteReceive, addon_data, &(addon_data->work));

  // Queue the work item for execution.
  napi_queue_async_work(env, addon_data->work);

  // This causes `undefined` to be returned to JavaScript.
  return NULL;
}